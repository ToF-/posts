---
layout: post
title: "Zombies"
subtitle: "product owning #3"
categories: coaching productowning
tags: tech-debt
---
# Zombies

Une application qui contribue pleinement Ã  la crÃ©ation de valeur dans l'entreprise mais dont la conception n'est plus vivante, est ce qu'on appelle dans notre jargon technique une application "legacy".
<!--more-->

La dÃ©finition Ã©lÃ©gante proposÃ©e par Nicolas Carlo va dans ce sens :

> Legacy Code is valuable code you're afraid to change.

Cette situation n'est pas nÃ©cessairement un problÃ¨me. Certaines solutions peuvent durer longtemps sans qu'il soit nÃ©cessaire pour l'entreprise d'y apporter des changements. Elles peuvent mÃªme finir par "migrer" vers la droite dans une carte de Wardley c'est Ã  dire devenir des commoditÃ©s. Lorsque la complexitÃ© essentielle d'une application peut Ãªtre absorbÃ©e par un acteur extÃ©rieur et faire l'objet d'une fourniture industrielle, cela indique que la solution a Ã©tÃ© "rationalisÃ©e" et que l'Ã©volution de sa conception ne constitue plus un enjeu stratÃ©gique.

En revanche, lorsqu'une solution apporte une valeur stratÃ©gique Ã  l'entreprise, alors selon toute probabilitÃ©, des changements importants touchant sa conception vont Ãªtre projetÃ©s, nÃ©gociÃ©s, parfois plus ou moins imposÃ©s. Sa conception a besoin de vivre. ğŸ©º

C'est la raison pour laquelle une Ã©quipe de dÃ©veloppement Ã©crit des tests, des commentaires et de la documentation. ğŸ“ğŸ“â„¹ï¸

C'est aussi la raison pour laquelle elle remanie le code : si elle peut donner Ã  son code une expressivitÃ© suffisante, alors le code sera plus facile Ã  changer, mÃªme si on n'Ã©crit pas de commentaire ni de documentation ! ğŸ˜

Voici un exemple trivial :

Supposons que dans la conception d'une application, partout oÃ¹ la TVA doit Ãªtre calculÃ©e, des programmeurs (inconscients) ont Ã©crit :

```
  prixTTC = prixHT * 1.20
```

Pour que ce code soit facile Ã  changer, deux tactiques possibles.

__Tactique A :__

âœ… chaque chemin d'exÃ©cution du code oÃ¹ une TVA est calculÃ©e fait l'objet d'un test auto-vÃ©rifiant

ğŸ”¬ l'emplacement du code oÃ¹ se situent ces calculs peut Ãªtre retrouvÃ© dans une liste ou par extraction

ğŸ¤“ note explicative sur ce qui peut arriver lorsqu'on fouille du code Ã  l'aide de l'expression rÃ©guliÃ¨re  `* 1.20` 

__Tactique B :__

ğŸ“¦ le calcul de la TVA fait l'objet d'un module TauxTva

âœ… ce module est Ã©quipÃ© de ses propres tests auto-vÃ©rifiants

ğŸ§ les contraventions Ã  son usage sont dÃ©tectÃ©es et discutÃ©es lors de la relecture du code

Supposons que ces programmeurs, extraits de leur lÃ©thargie au beau milieu du sprint par la remarque d'un stagiaire, rÃ©alisent qu'ils ont besoin d'appliquer la tactique A ou B. Ils en touchent un mot au PO qui leur tient Ã  peu prÃ¨s ce langage :

_ Foin des refactorings ! Vous vous ferez plaisir aprÃ¨s la mise en prod.

L'Ã©quipe referme ce dossier. Le logiciel est livrÃ© en prod. AprÃ¨s la mise en prod, il y a tellement de choses nouvelles Ã  faireâ€¦

Dans 5 ans une Ã©quipe va ouvrir le capot : whaaaat ?

ğŸ•¸ğŸ§Ÿâ€â™€ï¸ğŸ§ŸğŸ§Ÿâ€ğŸ•¸

En fait, c'Ã©tait le refacto de la derniÃ¨re chance. ğŸª¦

[publiÃ© sur LinkedIn le 09/03/2023](https://www.linkedin.com/posts/christophe-thibaut-35b4657_productowning-dettetechnique-activity-7039487229907369984-zCqw?utm_source=share&utm_medium=member_desktop)
