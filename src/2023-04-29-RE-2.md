---
layout: post
title: "PrÃ©venir > GuÃ©rir"
subtitle: "Regulation #2"
categories: Productivity Regulation
tags: TDD state-of-the-art productivity
---
# PrÃ©venir > GuÃ©rir

TDD est une stratÃ©gie *Diviser pour RÃ©gner* appliquÃ©e aux vÃ©rifications et aux refactorings de votre code. Le R.O.I, ce que vous gagnez Ã  acquÃ©rir et renforcer cette compÃ©tence, dÃ©pend de la taille de la base de code sur laquelle vous travaillez. 
<!--more-->

Comparer une solution dont le code est 90% vÃ©rifiÃ© Ã  une solution dont le code n'est pratiquement pas vÃ©rifiÃ© peut Ãªtre particuliÃ¨ment trompeur. Cela revient Ã  comparer deux choses diffÃ©rentes, et ne considÃ©rer que le prix. ğŸª£ ğŸ¤“ ğŸ§¯

Bien sÃ»r quand nous dÃ©veloppons du logiciel, nous devons Ãªtre vigilants sur les coÃ»ts, nos ressources sont limitÃ©es. Nous avons aussi besoin d'Ãªtre responsabilisÃ©s sur nos dÃ©cisions (entre autres : celles qui concerne les mÃ©thodes qui vont continuer de s'appliquer quand nous serons partis). Notre solution doit aussi Ãªtre soutenable en termes de coÃ»ts, de qualitÃ© et de facilitÃ© de maintenance.

Quand on adopte une stratÃ©gie *Code & Fix* sur un projet complexe, on proclame :

- on va faire ce projet en *Code & Fix*, parce que c'est moins cher ! ğŸª™ ğŸ’ª

Il serait honnÃªte de dÃ©voiler le raisonnement complet, avec ses consÃ©quences :

- tous les chemins d'exÃ©cution possibles du code ne seront pas vÃ©rifiÃ©s : ni au niveau unitaire, ni au niveau intÃ©gration ğŸ•³

- nous ne savons pas exactement lesquels seulement seront testÃ©s ğŸ°

- nous ne comptons pas le calculer, mais intuitivement, nous savons que l'alternative TDD serait du gÃ¢chis ğŸ”®

ğŸ¤·â€â™‚ï¸ 

ğŸ—ºğŸªœğŸ§¯

TDD est une instance de stratÃ©gie de prÃ©vention des dÃ©fauts.  

La prÃ©vention des dÃ©fauts est elle mÃªme une instance d'ingÃ©nierie bien comprise, telle que les humains la dÃ©veloppent en vue de faire face Ã  la complexitÃ©, et Ã  l'irreversibilitÃ© du temps.

Il vaut mieux prÃ©venir que guÃ©rir :

- Nous protÃ©geons les biens dont nous savons qu'ils seraient difficiles Ã  remplacer s'ils disparaissaient. ğŸ”

- Nous dÃ©pensons un peu d'Ã©nergie Ã  maintenir de l'ordre dans un systÃ¨me qui marche, pour Ã©viter de dÃ©penser une Ã©nergie incommensurable sur un systÃ¨me en dÃ©sordre qui ne marche plus. ğŸ—ƒ

Le bien que je protÃ¨ge en Ã©crivant un *check* (ou "test unitaire" ğŸ˜’) c'est la comprÃ©hension prÃ©cise que j'ai de ce chemin possible d'exÃ©cution du code au moment oÃ¹ j'Ã©cris le code. ğŸ—º

Le dÃ©sordre dont je me protÃ¨ge est celui qui serait crÃ©Ã© par un chemin d'exÃ©cution dÃ©fectueux enfoui parmi des milliers de chemins d'exÃ©cution possibles, eux mÃªmes liÃ©s Ã  des centaines d'Ã©tats possibles. C'est une forÃªt Ã©paisse et opaque, une botte de foin numÃ©rique dans laquelle je n'ai aucune envie d'avoir Ã  chercher une aiguille. ğŸ¤¯

Mon avis :

- ne vous enfermez pas dans un tunnel de code jusqu'Ã  vous trouver au sommet d'une solution ingÃ©rable, Ã  vous demander : attends, est-ce que Ã§a marche, au fait ?

- apprendre une nouvelle technique est plus facile au dÃ©but d'un projet qu'au milieu d'une crise

- est-ce qu'il faut vraiment TOUT construire comme si les solutions que nous crÃ©ons n'avaient aucun avenir ?

Stay Tuned !


[publiÃ© sur Linked In le 18/04/2023](https://www.linkedin.com/posts/christophe-thibaut-35b4657_systaeymes-tdd-legacycode-activity-7053973379938164737-wYNd?utm_source=share&utm_medium=member_desktop)
